########## Basic Poker-related Classes #########
from constants import *
from os import urandom

'''
Basic playing card. Doesn't include jokers
[want to make rank and suit enums]
decided not to make wildcards equal
but since I'm allowing wildcards, should be able to handle
them within the Card class.
'''
class Card:
    '''
    initialize Card w/ optional rank and suit.
    '''
    def __init__(self, rank=None, suit=None):
        if rank != None and suit != None:
            self.setRank(rank)
            self.setSuit(suit)
    '''
    create card from cardString (e.g. 'As')
    '''
    def create(self, cardString):
        self.setRank(cardString[0])
        self.setSuit(cardString[1])
    '''
    Set rank of card. Cannot override existing rank. Must be valid value.
    '''
    def setRank(self, rank):
        if self.rank != None:
            raise Exception(str.format("Card already has rank {0}", self.rank))
        if rank not in ranks_set and rank != wildcard_rank:
            raise ValueError("Invalid card rank.")
        self.rank = rank
    '''
    Set suit of card. Cannot override existing suit. Must be valid value.
    '''
    def setSuit(self, suit):
        if self.suit != None:
            raise Exception(str.format("Card already has suit {1}", self.suit))
        if suit not in suits_set and suit != wildcard_suit:
            raise ValueError("Invalid card suit.")
        self.suit = suit

    # Distinguish between "equality" and "matching" of ranks and suits
    # because wildcards "match" everything but only "equal" the same wildcard.
    def rankEquals(self, other):
        return self.rank == other.rank
    def rankMatches(self, other):
        if self.rank == wildcard_rank or other.rank == wildcard_rank:
            returnTrue
        return self.rankEquals(other)
    def suitEquals(self, other):
        return self.suit == other.suit
    def suitMatches(self, other):
        if self.suit == wildcard_suit or other.suit == wildcard_suit:
            return True
        return self.suitEquals(other)
    '''
    Determine if two cards match.
    '''
    def matches(self, other):
        return self.rankMatches(other) and self.suitMatches(other)
    def __eq__(self, other):
        return self.rankEquals(other) and self.suitEquals(other)
    def __str__(self):
        return self.rank+self.suit


'''
Match cards poker-style (e.g. Ax ~ As). hand is a poker hand, hands
is an iterable of poker hands.
'''
def containsHand(hand, hands):
    for h in hands:
        if hand.matches(h):
            return True
    return False

class PokerCardMatcher:
    def __init__(self):
        pass
    def matchesHand(self, hands):
        pass
    def matchesCard(self, identifier):
        pass
    

'''
HE hands (2 cards).
'''
class Hand:
    def __init__(self, card1=None, card2=None):
        self.card1 = card1
        self.card2 = card2
    def first(self):
        return self.card1
    def second(self):
        return self.card2
    def matches(self, other):
        return (self.card1.matches(other.card1) and
                self.card2.matches(other.card2)) or \
                (self.card2.matches(other.card1) and
                 self.card1.matches(other.card2))
    def __eq__(self, other):
        return (self.card1 == other.card1 and self.card2 == other.card2) or \
               (self.card2 == other.card1 and self.card1 == other.card2)
    def __str__(self):
        return str.format("[{0},{1}]", str(self.card1), self.card2)
        
'''
Random hand generator.
'''
class HandGenerator:
    def __init__(self, handSize=2):
        self.rng = Rng()
        # for changes
        self.handSize = handSize

    '''
    generate a random poker hand using strong RNG.
    '''
    def randomHand(self):
        # get two distinct int in [0,52)
        # use them to get distinct cards
        first = self.rng.randRange(52)
        second = self.rng.randRange(52)
        while first == second:
            second = self.rng.randRange(52)
        # make hand
        hand = Hand()
        hand.card1 = self.intToCard(first)
        hand.card2 = self.intToCard(second)
        return hand

    '''
    Takes int in [0,52) and converts it to one of the 52 cards in deck.
    '''
    def intToCard(self, n):
        rankIndex = n % 13
        suitIndex = n / 13
        rank, suit = self.getRank(rankIndex), self.getSuit(suitIndex)
        return Card(rank, suit)
    
    def getRank(self, i):
        return ranks_list[i]
    
    def getSuit(self,i):
        return suits_list[i]

class Rng:
    def __init__(self):
        self.generator = urandom
        self.intRange = 256
        
    '''
    generates a random int in [0,255]
    *can be expanded by allowing more random
    generated bytes.
    '''
    def randomInt(self):
        # only generate one random byte
        randomBytes = self.generator(1)
        return int(randomBytes.encode('hex'), 16)

    '''
    generates a random int in [0,n-1]
    n must be between [0,256]
    *goal to ensure that taking mods does not bias the
    random integers generated.
    '''
    def randRange(self, n):
        rangeMax = self.intRange / n * n
        random = self.randomInt()
        while random >= rangeMax:
            random = self.randomInt()
        return random % n

    def randElt(self, array):
        n = len(array)
        return array[self.randRange(n)]
        
